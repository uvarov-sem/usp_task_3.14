[< к содержанию](./readme.md)

## git status — Показать текущие изменения

Давайте создадим простой файл и добавим его в наш репозиторий. После этого мы выполняем команду git status и анализируем ее вывод:

`$ "Hello World" >> myfile.txt`  
`$ git status`  
`On branch master`  
`Your branch is up to date with 'origin/master'.`  

`Untracked files:`  
>>>`(use "git add <file>..." to include in what will be committed) myfile.txt`  

`nothing added to commit but untracked files present (use "git add" to track)`  

Команда выводит текущий подробный статус наших изменений . Первая часть показывает, синхронизированы ли локальная и удаленная ветки.

Далее в выводе отображается состояние рабочего дерева — список измененных в данный момент файлов со статусом их обслуживания. Как мы видим, файл myfile.txt в настоящее время находится в области рабочего каталога и не отслеживается Git.

## git add — отслеживать изменения

Чтобы начать отслеживать изменения, нам нужно переместить их в индекс с помощью команды git add:

`$ git add myfile.txt`  
`$ git stage *`  

Мы можем указать сразу несколько файлов, разделив их пробелом. Мы также можем указать все файлы, используя знак звездочки.

В качестве альтернативы мы также можем использовать команду git stage, которая является синонимом команды git add.

Давайте теперь проверим статус:

`$ git status`  
`On branch master`  
`Your branch is up to date with 'origin/master'.`  

`Changes to be committed:`  
>>`(use "git restore --staged <file>..." to unstage)`  
>>>>`new file:   myfile.txt`  

Как мы видим, Git начал отслеживать наши файлы.

## git restore & gitignore — отменить отслеживание изменений

Git позволяет удалять файлы из индекса . Если мы по ошибке переместили в него свои изменения и хотим временно отключить их отслеживание, используем git restore:

`$ git restore -S myfile.txt`  
`$ git status`  
`On branch master`  
`Your branch is up to date with 'origin/master'.`  

`Untracked files:`  
>>`(use "git add <file>..." to include in what will be committed)`  
>>>>`myfile.txt`  

Мы только что снова переместили наш файл в рабочую область и исключили его из дальнейших коммитов до тех пор, пока мы снова не подготовим его. Флаг -S (–staged) указывает Git восстановить только индекс репозитория.

Мы также можем навсегда исключить файлы и отключить их отслеживание. Для этого нам нужно создать файл .gitignore . Этот файл содержит шаблоны имен файлов и применяется ко всем файлам в текущем каталоге и его дочерних каталогах. Любые дальнейшие действия по добавлению будут игнорировать файлы, соответствующие этим шаблонам.

## git commit — сохранить изменения

Давайте вернём последние изменения и снова переместим наш файл в Staging Area :

`$ git add myfile.txt`  

Теперь пришло время сохранить нашу работу, поэтому нам нужно сделать коммит.

Коммит — это объект Git, который похож на снимок нашего репозитория в определенное время.

Чтобы зафиксировать изменения, воспользуемся командой git commit :

`$ git commit -m "My first commit"`  
`[master 8451901] My first commit`
`1 file changed, 1 insertion(+)`  
`create mode 100644 myfile.txt`  

Мы только что создали наш первый коммит локально.

Команда git commit содержит множество дополнительных опций для выполнения более сложных операций, которые мы можем проверить с помощью команды git commit –help .

Наиболее полезным является флаг -m , который указывает сообщение фиксации, описывающее изменения, сделанные в текущем моментальном снимке.

Наконец, давайте проверим статус:

`$ git status`  
`On branch master`  
`Your branch is ahead of 'origin/master' by 1 commit.`  
>>>`(use "git push" to publish your local commits)` 

`nothing to commit, working tree clean`  

Теперь наше рабочее дерево не содержит никаких дополнительных изменений, но локальный репозиторий содержит больше коммитов, чем его внешний источник. Поэтому, чтобы опубликовать наши изменения, мы должны синхронизировать локальные изменения с источником.

## git log & git show — проверка коммитов

После того, как мы создали коммит, мы можем проверить его детали. Коммиты включают множество дополнительных метаданных, таких как автор, временная метка и т. д.

Чтобы распечатать список коммитов текущей ветки, мы используем команду ____git log____:

`$ git log`  
`commit 845190154ed7a491a6143669c4ce88058fb93f8a (HEAD -> master)`  
`Author: ...`  
`Date: ...`  

>>>>`My first commit`  

`commit 9a1e11ec981b41e4b4b9c245a7a96cd6707f4705 (origin/master, origin/HEAD)`  
`...`  

По умолчанию список показывает историю коммитов текущей ветки в обратном хронологическом порядке.

Каждая запись содержит общие метаданные, такие как идентификатор коммита (уникальная контрольная сумма SHA-1), автор, дата и заданное сообщение.

Когда мы хотим углубиться в отдельный коммит, мы печатаем его детали, используя команду git show , за которой следует запрошенный идентификатор коммита:

`$ git show 845190154ed7a491a6143669c4ce88058fb93f8a`  
`commit 845190154ed7a491a6143669c4ce88058fb93f8a (HEAD -> master)`  
`Author: ...`  
`Date:...`  

`My first commit`  

`diff --git a/myfile.txt b/myfile.txt`  
`new file mode 100644`  
`index 0000000..557db03`  
`--- /dev/null`  
`+++ b/myfile.txt`  
`@@ -0,0 +1 @@`  
`+Hello World`  

На этот раз выходные данные также отображают различия, сделанные фиксацией по сравнению с предыдущим снимком с помощью команды git diff .

## git stash `` — Отложить изменения

Команда ___git stash___ временно откладывает сделанные нами изменения , возвращая рабочий каталог в соответствие с фиксацией HEAD . Это позволяет нам быстро переключать контекст и начинать работать над чем-то другим.

Давайте создадим еще один файл и добавим его в Staging Area. После этого запускаем git stash:

`$ touch myfile-2.txt; git add *`  
`$ git stash push`  
`Saved working directory and index state WIP on master: 8451901 My first commit`  

Теперь давайте попробуем перечислить файл:

`$ ls myfile-2.txt`  

`ls: myfile-2.txt: No such file or directory`  

Мы видим, что теперь файла нет. Это связано с тем, что все ожидающие изменения были удалены из рабочего каталога и сохранены в тайнике.

Мы можем распечатать все спрятанные модификации, используя опцию списка:

`$ git stash list`  
`stash@{0}: WIP on master: 8451901 My first commit`  

Поскольку мы не предоставили его описание, тайник по умолчанию указан как WIP на… . Мы можем изменить значение по умолчанию на более описательное сообщение, используя флаг -m в командной строке.

Чтобы проверить его детали, мы используем опцию show:

`$ git stash show`
>>`myfile-2.txt | 0`  
>>>`1 file changed, 0 insertions(+), 0 deletions(-)`  

На выходе выводится информация об изменениях, хранящихся в последнем тайнике.

Наконец, если мы хотим восстановить изменения, мы используем опцию pop :

`$ git stash pop`  
`...`  
`$ ls myfile-2.txt`  
`myfile-2.txt`  

Мы только что удалили одно спрятанное состояние из списка сундуков и применили его поверх текущего состояния.