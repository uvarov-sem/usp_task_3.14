# Управление историей коммитов

Теперь, когда мы научились сохранять изменения в репозитории, давайте изменим ранее сохраненные коммиты. В следующих разделах мы рассмотрим наиболее распространенные варианты использования.

## ___git commit –amend___ — добавить дополнительные изменения в коммит

Предположим, мы забыли включить файл при фиксации изменения. Конечно, мы можем создать еще один коммит поверх последнего, но это может запутать историю изменений.

В таких случаях мы можем захотеть, чтобы Git переписал нашу последнюю фиксацию и включил файл, который мы забыли, используя опцию исправления.

Давайте рассмотрим последний коммит:

`$ git show --summary`  
`commit 845190154ed7a491a6143669c4ce88058fb93f8a (HEAD -> master)`  
`Author: ...`  
`Date: ...`  

>>>`My first commit`  

>>`create mode 100644 myfile.txt`  

Получив наш файл **my-file2.txt** из тайника, давайте зафиксируем его, используя опцию исправления:

`$ git commit --amend`  
`[master 0ed9f03] My first commit`  
>>`2 files changed, 1 insertion(+)`  
`create mode 100644 myfile-2.txt`  
`create mode 100644 myfile.txt`  

Мы можем заметить, что Git добавил файл в нашу последнюю фиксацию, объединив изменения.

## ___git rebase___ — повторное применение коммитов

Более продвинутый способ изменения коммитов — использование команды git rebase . Он повторно применяет коммиты из истории поверх другой базы, что позволяет нам изменять их на лету.

Давайте создадим еще один коммит в нашем репозитории:

`$ touch myfile-3.txt`  
`$ git add *`  
`$ git commit -m "My second commit"`  

Теперь у нас должно быть два одиночных коммита — Мой первый коммит и Мой второй коммит.

Начнем перебазировать оба коммита в интерактивном режиме:

`git rebase -i HEAD~2`  

Откроется редактор, в котором мы можем манипулировать историей с помощью команд:

`pick 82d8635 My first commit`  
`pick 6d58108 My second commit`  

`# Rebase 9a1e11e..82d8635 onto 9a1e11e (2 commands)`  
`#`  
`# Commands:`  
`# p, pick <commit> = use commit`  
`# r, reword <commit> = use commit, but edit the commit message`  
`# e, edit <commit> = use commit, but stop for amending`  
`# s, squash <commit> = use commit, but meld into previous commit`  
`# d, drop <commit> = remove commit`  
`...`  

Вверху у нас есть список коммитов ребазинга, за которым следует руководство. У нас есть много вариантов здесь. Мы можем изменить порядок, поменяв местами строки, или перефразировать сообщение коммита, или сжать их в одно, отредактировать или даже удалить один коммит. Строки инструкций будут применяться сверху вниз.

## ___git reset___ — откат к определенному состоянию

Иногда нам может понадобиться отказаться от текущего состояния и вернуться к историческому моментальному снимку. Для этого воспользуемся опцией git reset:

`$ git reset 82d8635`  

Он отменяет все фиксации после указанной фиксации, сохраняя изменения локально и перемещая их в Staging Area. Но если мы хотим отказаться от всех рабочих изменений, мы можем использовать флаг –hard.